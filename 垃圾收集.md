# Javascript自动垃圾收集机制
* 找出那些不再继续使用的变量，释放其占有的内存
* 垃圾收集器会按照固定的时间间隔周期性的执行这一操作
* IE7以前：根据内存分配量达到临界值，垃圾收集器就会运行
* 最大的问题是，如果一个脚本包含这么多变量，很可能在其生命周期中一直有这么多变量，垃圾收集器会频繁的运行，引发严重性能问题 
* IE7以后，如果回收的内存低于15%，变量，对象字面量，数组的临界值加倍，如果回收的内存高于85%，临界值重置会默认值
* 标记清除
  * 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
  * 然后去掉环境中的变量，以及被环境中的变量引用的变量的标记
  * 那么剩下的被标记的变量就是准备删除的变量
  * 最后垃圾收集器完成内存清除工作，销毁值并回收他们占用的内存空间
* 引用计数 
  * 变量 对象字面量 数组
  * 跟踪记录每个值被引用的次数
  * 当一个值的引用次数变为0时，就将其占用的内存空间回收回来
  * 有问题，循环引用
  * 两个对象相互引用 永远也不会被回收
  * 怎么解决，手工断开他们之间的连接，将变量设为null,切断变量与值之间的连接，当垃圾收集器下次运行时，就会删除这些值并回收他们占用的内存。
  * 局部变量会在他们离开执行环境时自动被解除引用
  * 对于全局变量和全局对象的属性：为执行的代码只保存必要的数据，一旦数据不再有用，将其设置为null释放其引用
  * 不再用到的内存，没有及时释放，叫做内存泄露
  * 实时查看内存占用
  * 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏
  * 及时清除引用很重要，但有时你会忘
* ES6两种新的数据结构：WeakMap WeakSet
  * 对值的引用不计入垃圾回收机制 
  * 相当于声明那些引用可以忽略不计，其他引用消失以后，垃圾回收机制就可以释放内存。减轻程序员负担
