* 首先输网址，输的时候浏览器就只能匹配给你补全网址，从历史记录啊，书签啥的。
* 发起请求了，根据域名查一下它对应的IP,先去本地hosts查有没有匹配域名的IP,有就用，没有就上DNS服务器查去。
* 域名分好几层呢，根域名 顶级域名 次级域名 主机名
* 根域名服务器IP地址一般都给定了，直接向这些IP地址发请求，查顶级域名的服务器地址
* 查着以后，把最先回复的根域名服务器IP地址存上，以后就找他了，谁让他最积极呢。
* 再向查着的顶级域名服务器地址发请求，查次级域名服务器地址
* 查着以后在向次级域名服务器地址发请求，查主机IP
* 一般都会查着好几个
* 你每次查的域名服务器地址都能查着好几个，为啥呢，为了防止单点失败，一个没了，别的还好使，学名叫DNS负载均衡。
* 有时候用户太多，都访问一个服务器受不了，就多弄几个IP地址，多几个IP就是多几个服务器，大家都分担一下
* 现在我们拿着IP了哈
* 随机分个端口就发起TCP连接请求了吼
* 端口0-1023都被系统占了，咱就只能占1024-65535
对方的端口一般都是80
* Tcp连接建立完了，就可以发http请求了
* 且慢，咱们捋一捋Tcp连接吧
* Tcp就是为了传数据，
* 先建立连接三次握手，然后就开始传数据，最后把连接关了四次挥手
* 三次握手
* 咱们先把主动发起连接请求的一方叫客户端，被动等待连接建立的一方叫服务器
* 第一次握手：客户端SYN=1 seq=J 发给服务器，进入SYN_SEND状态
* 第二次握手：服务器收到了，把SYN和ACK都置为1，ack=J+1,seq=K,发给客户端，确认同意连接，自己进入SYN_RCVD状态
* 第三次握手：客户端收到人家确认的请求了，检查ack是不是J+1，ACK是不是1，确认完了，以后ACK=1,ack=K+1发给服务器。服务器一检查发现数据对，连接就建立成功了。
* 这时候两方都进入到ESTABLISHED状态。大家就可以开始传数据了
* 为啥非要三次握手：
* 假如网络卡了，客户端发的连接请求没传给服务器，过了好久，这个连接请求终于发给了服务端，这时客户端已经不想再连接了。但是服务器不知道啊，服务器就同意了这次连接，如果没有第三次握手，服务器就一直傻等，白白浪费自己的资源等待接收客户端给他传的数据
* 建立了TCP连接之后，发起一个http请求
* 再说说四次挥手：
* TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。 客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。
* 释放连接过程
* 在结束之前，通信双方都是处于 ESTABLISHED 状态，然后其中一方主动断开连接。 下面假如客户端先主动断开连接。
* 第一次挥手： 客户端向服务器发送结束报文段，然后进入 FIN_WAIT_1 状态。 此报文段 FIN = 1， Sequence Number = M。
* 第二次挥手： 服务端收到客户端的结束报文段，然后发送确认报文段，进入 CLOSE_WAIT 状态。 此报文段 ACK = 1， Sequence Number = M + 1。
* 客户端收到该报文，会进入 FIN_WAIT_2 状态。
* 第三次挥手： 同时服务端向客户端发送结束报文段，然后进入 LAST_ACK 状态。 此报文段 FIN = 1，Sequence Number = N。
* 第四次挥手： 客户端收到服务端的结束报文段，然后发送确认报文段，进入 TIME_WAIT 状态，经过 2MSL 之后，自动进入 CLOSED 状态。 此报文段 ACK = 1, Sequence Number = N + 1。
* 服务端收到该报文之后，进入 CLOSED 状态。
* 关于 TIME_WAIT 过渡到 CLOSED 状态说明： 从 TIME_WAIT 进入 CLOSED 需要经过 2MSL，其中 MSL 就叫做 最长报文段寿命（Maxinum Segment Lifetime），根据 RFC 793 建议该值这是为 2 分钟，也就是说需要经过 4 分钟，才进入 CLOSED 状态。
* 为什么不立刻closed:俩原因
* 万一服务器没收到ACK,会向客户端再次发送请求，但是客户端已经closed,就会报错。
* 假如立即closed,然后又建立了一个连接，分的端口号又恰巧跟上次一样，又恰好上次连接还有一些数据滞留了，这次发过来了，那么作废的数据和有用的数据万一有重名，就出问题了。所以多等一会，让本次连接的所有数据都从网络中消失。
* 实体层 链接层 网络层 传输层 应用层 
* 终于说完了。
* 我们把HTTP数据包塞进TCP数据包，TCP数据包标头是己方端口（随机）和服务器端口80，TCP数据包塞进IP数据包，IP数据包标头是发送方和接收方IP地址，IP数据包塞进以太网数据包，以太网数据包标头双方的MAC地址，再上层就是物理层了，01信号在电缆光缆双绞线中传啊传
* 咋知道接收方的MAC地址（网卡地址）：用IP地址根据ARP协议得到
* 如果在同一个子网，用ARP协议，向子网内所有主机发数据包，每个主机自己比较数据包里的IP跟自己一不一样，不一样丢弃，一样就返回自己的MAC地址。

* 数据包主要是一个网卡传向另一个网卡。
* 先看是不是在同一个子网，广播发送数据包，根据MAC地址确认自己是不是接收方。
* 如果不在同一个子网，就把数据包给网关，让网关去处理
* 以太网数据包最大1500字节，IP数据包如果过大就切割成几个包发送，把每个包编上号。
* 目标主机收着数据包了，操作系统组装还原数据包，TCP给每个包都编了号seq，每个数据包都有两个编号自身编号和下一个包的编号。
* 操作系统组装好了就根据端口发给应用程序
* TCP慢启动机制，建立完连接开始发包，一开始发的特别慢，根据丢包情况调整速率，接收方每收到两个数据包就发一个ACK,ACK包含期待的下一个数据包编号和接受窗口容量。如果下一个期待的数据包没有收到，ACK中的编号不会变，发现收到三个重复的ACK,确认丢包，从而再次发送这个包。
* 由此得到完整的TCP数据包，取出其中的HTTP请求。
* 反向代理：一些网站访问量太大，就会将http请求先发到反向代理服务器中，将这些请求分发给多台机器处理。
* 服务器处理完请求给个HTTP响应，这个响应也是通过TCP协议发回来。
* 收到了http响应就可以将页面显示出来了，网络通信就是这么个流程。
* 网页咋渲染的：
* HTML代码转化为DOM
* CSS代码转化为CSSOM
* 结合DOM和CSSOM生成一棵渲染树
* 重排也就是生成布局
* 重绘就是把布局绘制在屏幕上

* 导致网页性能下降的根本原因：不断地重排和重绘
* 什么会导致网页重新渲染：
* DOM变了 CSS变了 鼠标悬停页面滚动等事件
* 我们要怎么提高网页性能：尽量少触发网页重新渲染
* 浏览器还是很智能的，他会尽量把变动放在一起，一起渲染。
* 但是一些读操作会引起浏览器立即重新渲染。
* offsetHeight offsetWidth offsetLeft offsetTop
* scrollHeight scrollWidth scrollLeft scrollTop
* clientHeight clientWidth clientLeft clientTop
* getComputedStyle()

* 所以咱们尽量把读操作写一起，写操作写一起
* 别一行读，一行写，一行读，一行写
* 还有
* Table重排和重绘的成本比div高，这就是为啥老说让少用table
* DOM层级越高重排重绘成本越高
* 样式表越简单重排重绘成本越小
* DocumentFragment特别不错，对它操作不会影响现有的页面布局
* 同样原理，cloneNode()
* 把他俩操作完了再一次性插到页面里
* Position是absolute或fixed重排开销小，因为他俩对别的元素没影响
* 先将元素值为display:none在对他进行100此操作，最后再恢复它，相当于用两次渲染代替100次渲染

* 别一条条写样式，用className或者cssText,一次性多改变样式。

* 有时候密集的重新渲染不可避免，比如scroll事件或者动画
* 用requestAnimationFrame()将重新渲染和显示器刷新频率同步，避免多次渲染但是显示器根本来不及显示这种变化，达到最佳视觉效果。
