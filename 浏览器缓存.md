客户端缓存的意义：将一些不经常变化的文件存储起来，优化用户浏览体验。
# 根据是否需要重新向服务器发起请求分类
* 强制缓存
   * 响应header里Cache-Control（HTTP 1.1）
        * private 
        * public 
        * max-age：缓存的内容将在多少秒后失效 
        * no-cache：需要使用对比缓存来验证缓存数据
        * no-store：所有内容都不会缓存
  * 客户端向缓存数据库请求数据
    * 有缓存数据，且未失效，返回数据
    * 缓存数据失效，客户端向服务器请求数据，服务器返回数据和缓存规则。客户端将数据和缓存规则存入缓存系统。
* 对比缓存
  * 有个文件可能时不时会更新一下，服务端希望客户端能时不时来问一下文件是否有更新，如果没有，服务端就不返数据给你，只返回一个状态码304。
  * 客户端向缓存数据库获取缓存数据的标识
    * 将这个标识发给服务器，请求服务器验证缓存标识对应的数据是否失效。
  * 服务器通知客户端缓存未失效，客户端去缓存数据库获取缓存数据
  * 数据失效，服务器返回最新数据和缓存规则，客户端将数据和缓存规则存入缓存数据库。
  * 缓存标识：在请求header和响应header之间传递。有两种:
    * Last-Modified  
      * 服务器在响应中有LastModified,告诉浏览器资源的最后修改时间。
    * If-Modified-Since
      * 客户端请求服务器时，把这个值放在If-Modified-Since,服务器收到请求后，将其与被请求资源的最后修改时间对比。
      * 如果最后修改时间大于If-Modified-Since,说明资源被改动了，响应整片资源内容。，返回状态码200。如果资源的最后修改日期小于等于If-Modified-Since，说明资源无新修改，响应状态码304。
    * Etag If-None-Match
      * 客户端第一次访问资源时，服务器返回Etag:1234,告诉客户端这个文件的标签是1234，如果修改了这个文件，这个标签就会不一样了。
      * 下次访问资源时，客户端带上If-None-Match,告诉服务器如果那边的资源标签还是1234，就返回304，否则返回资源内容和200。
      * Etag很少有人用，他会用算法，占用服务器计算的资源。
* 强制缓存如果生效，不需要再和服务器发生交互。
* 对比缓存不管是否生效，都要和服务器发生交互。
* 两种缓存规则可以同时存在
  * 强制缓存优先级别高于对比缓存，只要强制缓存生效了，就不用执行对比缓存了。
# 三种刷新：
* 浏览器中写地址，回车
    * 强制缓存 最快
* F5
  * 客户端会发If-Modified-Since
* Ctrl+F5
  * 把缓存中的这个文件给我删了，重新去服务器请求个完整的资源文件下来。客户端完成了强行更新的操作。
